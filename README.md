# TinyString
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by badges.sh from github.com/cdvelop/devscripts"></a>
<!-- END_SECTION:BADGES_SECTION -->

TinyString is a lightweight Go library that provides comprehensive string manipulation, type conversion, formatting, and multilingual error handling with a fluid API, specifically designed for small devices and web applications using TinyGo as the target compiler.

## Key Features

- üöÄ **Fluid and chainable API** - Easy to use and readable operations
- üìù **Complete string toolkit** - Transformations, conversions, formatting, and error handling
- üåç **Multilingual error messages** - Built-in dictionary system with 9 languages
- üßµ **Concurrency safe** - Thread-safe operations for concurrent environments
- üì¶ **Zero dependencies** - No `fmt`, `strings`, `strconv`, or `errors` imports
- üéØ **TinyGo optimized** - Manual implementations for minimal binary size
- üåê **WebAssembly-first** - Designed for modern web deployment
- üîÑ **Universal type support** - Works with strings, numbers, booleans, and slices
- ‚ö° **Performance focused** - Predictable allocations and custom optimizations

## [Why TinyString?](docs/WHY.md)

## Installation

```bash
go get github.com/cdvelop/tinystring
```

## Usage

```go
import . "github.com/cdvelop/tinystring"

// Quick start - Basic conversion and transformation
text := Convert("H√≥la M√∫ndo").Tilde().Low().String() // out: "hola mundo"

// Working with different data types
numText := Convert(42).String()     // out: "42"
boolText := Convert(true).String()  // out: "true"

// Memory-efficient approach using string pointers
original := "√âl M√∫rcielago R√°pido"
Convert(&original).Tilde().CamelLow().Apply()
// original is now: "elMurcielagoRapido"

// // Efficient, Unified builder and chaining example usage in loops and reuse, with accent normalization (Tilde)
// Note: √± and √ë are preserved by Tilde eg:
items := []string{"  √ÅPPLE  ", "  ban√°na  ", "  pi√±ata  ","  √ëAND√ö  "}
c := Convert() // without params reused buffer = optimal performance
for i, item := range items {
    c.Write(item)
    .Trim()      // Trim whitespace
    .Tilde()     // Remove accents and diacritics
    .Low()       // Convert to lowercase or .Up() for uppercase
    .Capitalize()// Capitalize first letter

    if i < len(items)-1 {
        c.Write(" - ")
    }
}

// Finalize the string hiding the error
out := c.String() 
// OR finalize with error handling if any operation failed
out, err := c.StringErr() 
// out: "Apple - Banana - Pi√±ata - √ëandu", err: nil


// Multilingual error messages
OutLang(ES) // Set Spanish
err := Err(D.Invalid, D.Format) // out: "inv√°lido formato"

OutLang()   // Auto-detect system language
err = Err(D.Cannot, D.Round, D.NonNumeric, D.Value).Error()
// Output in user's detected language
```

## üìö Standard Library Equivalents

### üî§ strings Package

Replace common `strings` package functions with TinyString equivalents:

| Go Standard | TinyString Equivalent |
|-------------|----------------------|
| `strings.Low()` | `Convert(s).Low().String()` |
| `strings.Up()` | `Convert(s).Up().String()` |
| `strings.Contains()` | `Contains(s, substr)` |
| `strings.Replace()` | `Convert(s).Replace(old, new).String()` |
| `strings.Split()` | `Convert(s).Split(sep).String()` |
| `strings.Join()` | `Convert(slice).Join(sep).String()` |
| `strings.TrimSpace()` | `Convert(s).Trim().String()` |
| `strings.TrimPrefix()` | `Convert(s).TrimPrefix(prefix).String()` |
| `strings.TrimSuffix()` | `Convert(s).TrimSuffix(suffix).String()` |
| `strings.Repeat()` | `Convert(s).Repeat(n).String()` |
| `strings.Builder` | `c:= Convert() c.Write(a) c.Write(b) c.String()` |

#### Builder API Advantages

The Builder API is especially efficient for complex operations:

```go
// ‚ùå Standard approach - multiple allocations
result := tinystring.Convert("Hello").Up().String() + " " + 
          tinystring.Convert("World").Low().String() + "!"
// Multiple Convert() calls = multiple allocations

// Unified builder and chaining example
b := Convert()
b.Write("  H√ìLA M√öNDO  ").Trim().Tilde().Low().Replace(" ", "_")
b.Write("!")
result := b.String() // "hola_mundo!"
// Single Convert() + reused buffer = optimal performance
```

#### Other String Transformations

```go
Convert("hello world").CamelLow().String() // out: "helloWorld"
Convert("hello world").CamelUp().String()  // out: "HelloWorld"
Convert("hello world").SnakeLow().String() // out: "hello_world"
Convert("hello world").SnakeUp().String()  // out: "HELLO_WORLD"
```

#### String Search & Operations

```go
// Search and count
found := Contains("hello world", "world")              // out: true
count := Count("abracadabra", "abra")       // out: 2

// ‚ö†Ô∏è Note: Contains is a global function, not a method.
// Do NOT use: Convert(s).Contains(substr) // ‚ùå Incorrect, will not compile
// Use:        Contains(s, substr)         // ‚úÖ Correct

// Replace operations
Convert("hello world").Replace("world", "Go").String() // out: "hello Go"
Convert("test 123 test").Replace(123, 456).String()    // out: "test 456 test"
```

#### String Splitting & Joining

```go
// Split strings (always use Convert(...).Split(...))
parts := Convert("apple,banana,cherry").Split(",")
// out: []string{"apple", "banana", "cherry"}

parts := Convert("hello world new").Split()  // Handles whitespace
// out: []string{"hello", "world", "new"}

// Join slices
Convert([]string{"Hello", "World"}).Join().String()    // out: "Hello World"
Convert([]string{"a", "b", "c"}).Join("-").String()    // out: "a-b-c"
```

#### String Trimming & Cleaning

```go
// Trim operations
Convert("  hello  ").Trim().String()                    // out: "hello"
Convert("prefix-data").TrimPrefix("prefix-").String()   // out: "data"
Convert("file.txt").TrimSuffix(".txt").String()         // out: "file"

// Repeat strings
Convert("Go").Repeat(3).String()                        // out: "GoGoGo"
```

### üî¢ strconv Package

Replace `strconv` package functions for type conversions:

| Go Standard | TinyString Equivalent |
|-------------|----------------------|
| `strconv.Itoa()` | `Convert(i).String()` |
| `strconv.Atoi()` | `Convert(s).Int()` |
| `strconv.ParseFloat()` | `Convert(s).Float64()` |
| `strconv.ParseBool()` | `Convert(s).ToBool()` |
| `strconv.FormatFloat()` | `Convert(f).Round(n).String()` |
| `strconv.Quote()` | `Convert(s).Quote().String()` |

#### Type Conversions

```go
// String to numbers => Int,Int32,Int64,Uint,Uint32,Uint64,Float32,Float64 eg:
result, err := tinystring.Convert("123").Int()        // out: 123, nil
result, err := tinystring.Convert("456").Uint()       // out: 456, nil  
result, err := tinystring.Convert("3.14").Float64()     // out: 3.14, nil

// Numbers to string
tinystring.Convert(42).String()      // out: "42"
tinystring.Convert(3.14159).String() // out: "3.14159"

// Boolean conversions
result, err := tinystring.Convert("true").ToBool()  // out: true, nil
result, err := tinystring.Convert(42).ToBool()      // out: true, nil (non-zero = true)
result, err := tinystring.Convert(0).ToBool()       // out: false, nil

// String quoting
tinystring.Convert("hello").Quote().String()           // out: "\"hello\""
tinystring.Convert("say \"hello\"").Quote().String()  // out: "\"say \\\"hello\\\"\""
```

#### Number Formatting
```go
// Decimal rounding: keep N decimals, round or truncate
// By default, rounds using "round half to even" (bankers rounding)
// Pass true as the second argument to truncate (no rounding), e.g.:
Convert("3.14159").Round(2).String()        // "3.14" (rounded)
Convert("3.155").Round(2).String()          // "3.16" (rounded)
Convert("3.14159").Round(2, true).String()  // "3.14" (truncated, NOT rounded)
Convert("3.159").Round(2, true).String()    // "3.15" (truncated, NOT rounded)

// Formatting with thousands separator
tinystring.Convert(2189009.00).Thousands().String()        // out: "2.189.009"
```

### üñ®Ô∏è fmt Package

Replace `fmt` package functions for formatting:

| Go Standard | TinyString Equivalent |
|-------------|----------------------|
| `fmt.Sprintf()` | `Fmt(format, args...)` |
| `fmt.Sprint()` | `Convert(v).String()` |

#### String Formatting

```go
// Printf-style formatting
result := Fmt("Hello %s, you have %d messages", "John", 5)
// out: "Hello John, you have 5 messages"

// Multiple format specifiers
result := Fmt("Number: %d, Float: %.2f, Bool: %v", 42, 3.14159, true)
// out: "Number: 42, Float: 3.14, Bool: true"

// Advanced formatting (hex, binary, octal)
result := Fmt("Hex: %x, Binary: %b, Octal: %o", 255, 10, 8)
// out: "Hex: ff, Binary: 1010, Octal: 10"
```

### ‚ùå errors Package

Replace `errors` package functions for error handling with multilingual support:

| Go Standard | TinyString Equivalent |
|-------------|----------------------|
| `errors.New()` | `Err(message)` |
| `fmt.Errorf()` | `Errf(format, args...)` |

#### Error Creation

```go
// Multiple error messages and types
err := Err("invalid format", "expected number", 404)
// out: "invalid format expected number 404"

// Formatted errors (like fmt.Errorf)
err := Errf("invalid value: %s at position %d", "abc", 5)
// out: "invalid value: abc at position 5"

```
## üöÄ TinyString Exclusive Features

### üåç TinyString: Multilingual & Translation Support

**TinyString** enables multilingual error messages using reusable dictionary terms. It supports 9 languages and allows global or inline language selection.

```go
OutLang(ES) // Set global language to Spanish or OutLang() without parameters to Auto-detect system/browser language

err := Err(D.Format, D.Invalid)
// ‚Üí "formato inv√°lido"

// Force French
err = Err(FR, D.Empty, D.String)
// ‚Üí "vide cha√Æne"
```
See [`dictionary.go`](dictionary.go) for built-in words.
Combine `D.` (default terms) and custom dictionaries for flexible messaging.

üìò Full documentation available in [`docs/TRANSLATE.md`](docs/TRANSLATE.md)


### ‚úÇÔ∏è Smart Truncation

```go
// Basic truncation with ellipsis
Convert("Hello, World!").Truncate(10).String()       
// out: "Hello, ..."

// Name truncation for UI display
Convert("Jeronimo Dominguez").TruncateName(3, 15).String()
// out: "Jer. Dominguez"

// Advanced name handling
Convert("Juan Carlos Rodriguez").TruncateName(3, 20).String()
// out: "Jua. Car. Rodriguez"
```

### üîß Advanced Utilities

```go
// Key-value parsing with the new API:
value, err := Convert("user:admin").KV()            // out: "admin", nil
value, err := Convert("count=42").KV("=")          // out: "42", nil

// Snake case with custom separators
Convert("hello world").SnakeLow("-").String() // out: "hello-world"
Convert("hello world").SnakeUp("_").String() // out: "HELLO_WORLD"
```

## üí° Performance Tips String() vs Apply()

```go
// String() - Returns the result, original remains unchanged
original := "√âl M√∫rcielago R√°pido"
result := tinystring.Convert(original).Tilde().Low().String()
// result: "el murcielago rapido"

// Apply() - Modifies the original string directly (more memory efficient)
// note: only support strings pointer
tinystring.Convert(&original).Tilde().Low().Apply()
// original: "el murcielago rapido"

// There are only two ways to finalize operations: using String() or Apply()
```
---
## [Benchmarking](benchmark/README.md)
---
## [Contributing](docs/CONTRIBUTING.md)