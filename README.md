# TinyString
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by badges.sh from github.com/cdvelop/devscripts"></a>
<!-- END_SECTION:BADGES_SECTION -->


TinyString is a lightweight Go library that provides comprehensive string manipulation, type conversion, formatting, and multilingual error handling with a fluid API, specifically designed for small devices and web applications using TinyGo as the target compiler.

## Key Features

- 🚀 **Fluid and chainable API** - Easy to use and readable operations
- 📝 **Complete string toolkit** - Transformations, conversions, formatting, and error handling
- 🌍 **Multilingual error messages** - Built-in dictionary system with 9 languages
- 🧵 **Concurrency safe** - Thread-safe operations for concurrent environments
- 📦 **Zero dependencies** - No `fmt`, `strings`, `strconv`, or `errors` imports
- 🎯 **TinyGo optimized** - Manual implementations for minimal binary size
- 🌐 **WebAssembly-first** - Designed for modern web deployment
- 🔄 **Universal type support** - Works with strings, numbers, booleans, and slices
- ⚡ **Performance focused** - Predictable allocations and custom optimizations

## Why TinyString?

**Go's WebAssembly potential is incredible**, but traditional applications face a critical challenge: **massive binary sizes** that make web deployment impractical.

### The Problem
Every Go project needs string manipulation, type conversion, and error handling - but importing standard library packages (`fmt`, `strings`, `strconv`, `errors`) creates significant binary bloat that hurts:

- 🌐 **Web app performance** - Slow loading times and poor user experience
- � **Edge deployment** - Resource constraints on small devices  
- 🚀 **Distribution efficiency** - Large binaries for simple operations

### The Solution
TinyString replaces multiple standard library packages with **lightweight, manual implementations** that deliver:

- 🏆 **Up to smaller binaries** - Dramatic size reduction for WebAssembly
- ✅ **Full TinyGo compatibility** - No compilation issues or warnings
- 🎯 **Predictable performance** - No hidden allocations or overhead
- 🔧 **Familiar API** - Drop-in replacement for standard library functions


## Installation

```bash
go get github.com/cdvelop/tinystring
```

## Usage

```go
import "github.com/cdvelop/tinystring"

// Quick start - Basic conversion and transformation
text := tinystring.Convert("Hóla Múndo").RemoveTilde().ToLower().String()
// out: "hola mundo"

// Working with different data types
numText := tinystring.Convert(42).String()     // out: "42"
boolText := tinystring.Convert(true).String()  // out: "true"

// Memory-efficient approach using string pointers
original := "Él Múrcielago Rápido"
tinystring.Convert(&original).RemoveTilde().CamelCaseLower().Apply()
// original is now: "elMurcielagoRapido"

// Multilingual error messages (NEW!)
import . "github.com/cdvelop/tinystring"

OutLang(ES) // Set Spanish
err := Err(D.Invalid, D.Format)
// out: "inválido formato"

OutLang()   // Auto-detect system language
err = Err(D.Cannot, D.Round, D.NonNumeric, D.Value).Error()
// Output in user's detected language
```

## 🔧 Builder API

TinyString features a **high-performance builder API** for memory-efficient string operations. All operations work on a single internal buffer with object pooling.

### Efficient Loop Processing

```go
import "github.com/cdvelop/tinystring"

// Memory-efficient processing in loops
items := []string{"  APPLE  ", "  banana  ", "  Cherry  "}

c := tinystring.Convert() // Empty initialization
for i, item := range items {
    c.Write(item).Trim().ToLower().Capitalize()
    if i < len(items)-1 {
        c.Write(" - ")
    }
}
result := c.String() // "Apple - Banana - Cherry"
```

### Key Builder Operations

```go
// Reuse builder for multiple operations
builder := tinystring.Convert()

// Operation 1: Reset and build
builder.Reset()
result1 := builder.Write("Hello").Write(" World").String()

// Operation 2: Reset and transform
builder.Reset()
original := "test string"
tinystring.Convert(&original).ToUpper().RemoveTilde().Apply()
// original is now: "TEST STRING" - modified in-place
```

## 📚 Standard Library Equivalents

### 🔤 strings Package

Replace common `strings` package functions with TinyString equivalents:

| Go Standard | TinyString Equivalent |
|-------------|----------------------|
| `strings.ToLower()` | `Convert(s).ToLower().String()` |
| `strings.ToUpper()` | `Convert(s).ToUpper().String()` |
| `strings.Contains()` | `Contains(s, substr)` |
| `strings.Replace()` | `Convert(s).Replace(old, new).String()` |
| `strings.Split()` | `Split(s, sep)` |
| `strings.Join()` | `Convert(slice).Join(sep).String()` |
| `strings.TrimSpace()` | `Convert(s).Trim().String()` |
| `strings.TrimPrefix()` | `Convert(s).TrimPrefix(prefix).String()` |
| `strings.TrimSuffix()` | `Convert(s).TrimSuffix(suffix).String()` |
| `strings.Repeat()` | `Convert(s).Repeat(n).String()` |
| `strings.Builder` | `Convert().Write(a).Write(b).String()` |

#### Builder API Advantages

The Builder API is especially efficient for complex operations:

```go
// ❌ Standard approach - multiple allocations
result := tinystring.Convert("Hello").ToUpper().String() + " " + 
          tinystring.Convert("World").ToLower().String() + "!"
// Multiple Convert() calls = multiple allocations

// ✅ Builder approach - single allocation
result := tinystring.Convert().
    Write("Hello").ToUpper().
    Write(" ").
    Write("World").ToLower().
    Write("!").
    String()
// Single Convert() + reused buffer = optimal performance
```

#### String Transformations

```go
// Case conversions
tinystring.Convert("HELLO").ToLower().String()              // out: "hello"
tinystring.Convert("world").ToUpper().String()              // out: "WORLD"
tinystring.Convert("hello world").Capitalize().String()     // out: "Hello World"

// Advanced case styles
tinystring.Convert("hello world").CamelCaseLower().String()   // out: "helloWorld"
tinystring.Convert("hello world").CamelCaseUpper().String()   // out: "HelloWorld"
tinystring.Convert("hello world").ToSnakeCaseLower().String() // out: "hello_world"
tinystring.Convert("hello world").ToSnakeCaseUpper().String() // out: "HELLO_WORLD"
```

#### String Search & Operations

```go
// Search and count
found := tinystring.Contains("hello world", "world")              // out: true
count := tinystring.Count("abracadabra", "abra")       // out: 2

// Replace operations
tinystring.Convert("hello world").Replace("world", "Go").String() // out: "hello Go"
tinystring.Convert("test 123 test").Replace(123, 456).String()    // out: "test 456 test"
```

#### String Splitting & Joining

```go
// Split strings
parts := tinystring.Split("apple,banana,cherry", ",")    
// out: []string{"apple", "banana", "cherry"}

parts := tinystring.Split("hello\tworld\nnew")  // Handles whitespace
// out: []string{"hello", "world", "new"}

// Join slices
tinystring.Convert([]string{"Hello", "World"}).Join().String()    // out: "Hello World"
tinystring.Convert([]string{"a", "b", "c"}).Join("-").String()    // out: "a-b-c"
```

#### String Trimming & Cleaning

```go
// Trim operations
tinystring.Convert("  hello  ").Trim().String()                    // out: "hello"
tinystring.Convert("prefix-data").TrimPrefix("prefix-").String()    // out: "data"
tinystring.Convert("file.txt").TrimSuffix(".txt").String()          // out: "file"

// Repeat strings
tinystring.Convert("Go").Repeat(3).String()                        // out: "GoGoGo"
```

### 🔢 strconv Package

Replace `strconv` package functions for type conversions:

| Go Standard | TinyString Equivalent |
|-------------|----------------------|
| `strconv.Itoa()` | `Convert(i).String()` |
| `strconv.Atoi()` | `Convert(s).ToInt()` |
| `strconv.ParseFloat()` | `Convert(s).ToFloat()` |
| `strconv.ParseBool()` | `Convert(s).ToBool()` |
| `strconv.FormatFloat()` | `Convert(f).RoundDecimals(n).String()` |
| `strconv.Quote()` | `Convert(s).Quote().String()` |

#### Type Conversions

```go
// String to numbers
result, err := tinystring.Convert("123").ToInt()        // out: 123, nil
result, err := tinystring.Convert("456").ToUint()       // out: 456, nil  
result, err := tinystring.Convert("3.14").ToFloat()     // out: 3.14, nil

// Numbers to string
tinystring.Convert(42).String()      // out: "42"
tinystring.Convert(3.14159).String() // out: "3.14159"

// Boolean conversions
result, err := tinystring.Convert("true").ToBool()  // out: true, nil
result, err := tinystring.Convert(42).ToBool()      // out: true, nil (non-zero = true)
result, err := tinystring.Convert(0).ToBool()       // out: false, nil

// String quoting
tinystring.Convert("hello").Quote().String()                    // out: "\"hello\""
tinystring.Convert("say \"hello\"").Quote().String()           // out: "\"say \\\"hello\\\"\""
```

#### Number Formatting

```go
// Decimal rounding
tinystring.Convert(3.154).RoundDecimals(2).String()           // out: "3.16" (ceiling)
tinystring.Convert(3.154).RoundDecimals(2).Down().String()    // out: "3.15" (floor)

// Number formatting with thousands separator
tinystring.Convert(2189009.00).FormatNumber().String()        // out: "2.189.009"
```

### 🖨️ fmt Package

Replace `fmt` package functions for formatting:

| Go Standard | TinyString Equivalent |
|-------------|----------------------|
| `fmt.Sprintf()` | `Fmt(format, args...)` |
| `fmt.Sprint()` | `Convert(v).String()` |

#### String Formatting

```go
// Printf-style formatting
result := tinystring.Fmt("Hello %s, you have %d messages", "John", 5)
// out: "Hello John, you have 5 messages"

// Multiple format specifiers
result := tinystring.Fmt("Number: %d, Float: %.2f, Bool: %v", 42, 3.14159, true)
// out: "Number: 42, Float: 3.14, Bool: true"

// Advanced formatting (hex, binary, octal)
result := tinystring.Fmt("Hex: %x, Binary: %b, Octal: %o", 255, 10, 8)
// out: "Hex: ff, Binary: 1010, Octal: 10"
```

### ❌ errors Package

Replace `errors` package functions for error handling with multilingual support:

| Go Standard | TinyString Equivalent |
|-------------|----------------------|
| `errors.New()` | `Err(message)` |
| `fmt.Errorf()` | `Errf(format, args...)` |

#### Error Creation

```go
// Simple error creation
err := tinystring.Err("invalid input")
// out: "invalid input"

// Multiple error messages
err := tinystring.Err("invalid format", "expected number")
// out: "invalid format expected number"

// Formatted errors (like fmt.Errorf)
err := tinystring.Errf("invalid value: %s at position %d", "abc", 5)
// out: "invalid value: abc at position 5"

```
## 🚀 TinyString Exclusive Features

#### 🌍 Multilingual Error Messages

TinyString includes a comprehensive dictionary system for creating multilingual error messages:

```go
import . "github.com/cdvelop/tinystring"

// Configure default language
OutLang(ES) // Spanish

// Use dictionary words to create error messages
err := Err(D.Invalid, D.Format)
// out: "inválido formato" (Spanish)

// Complex error message composition
err := Err(D.Negative, D.Numbers, D.Not, D.Supported)
// out: "negativo números no soportado" (Spanish)

// Mix languages inline
err := Err(FR, D.Empty, D.String)
// out: "vide chaîne" (French)

// Auto-detect system language
OutLang() // Detects browser/OS language automatically
err := Err(D.Cannot, D.Round, D.NonNumeric, D.Value)
// Output in user's system language
```

#### 🗣️ Supported Languages

The dictionary system supports 9 languages, prioritized by global reach to ensure optimal binary size.

**Core Essential Languages:**
- 🇺🇸 **EN** - English (default)
- 🇪🇸 **ES** - Spanish
- 🇨🇳 **ZH** - Chinese
- 🇮🇳 **HI** - Hindi
- 🇸🇦 **AR** - Arabic

**Extended Reach Languages:**
- 🇧🇷 **PT** - Portuguese
- 🇫🇷 **FR** - French
- 🇩🇪 **DE** - German
- 🇷🇺 **RU** - Russian

#### 📖 Dictionary Words

The dictionary contains essential words for error composition:

```go
// Common error words (alphabetically sorted)
D.Argument    // "argument", "argumento", "argumento", "argument"...
D.Base        // "base", "base", "base", "base"...
D.Cannot      // "cannot", "no puede", "não pode", "ne peut pas"...
D.Empty       // "empty", "vacío", "vazio", "vide"...
D.Format      // "format", "formato", "formato", "format"...
D.Invalid     // "invalid", "inválido", "inválido", "invalide"...
D.Missing     // "missing", "falta", "ausente", "manquant"...
D.Number      // "number", "número", "número", "nombre"...
D.String      // "string", "cadena", "string", "chaîne"...
D.Supported   // "supported", "soportado", "suportado", "pris en charge"...
D.Type        // "type", "tipo", "tipo", "type"...
D.Value       // "value", "valor", "valor", "valeur"...
// ... and more
```

#### 🎨 Custom Dictionary Extensions

Create your own dictionary words for domain-specific errors:

```go
// Define custom dictionary for your application
type MyDict struct {
    User     LocStr
    Email    LocStr
    Password LocStr
    Login    LocStr
}

// Initialize with translations
var MD = MyDict{
    User: LocStr{
        "user",            // EN
        "usuario",         // ES
        "usuário",         // PT
        "utilisateur",     // FR
        "пользователь",    // RU
        "Benutzer",        // DE
        "utente",          // IT
        "उपयोगकर्ता",      // HI
        "ব্যবহারকারী",     // BN
        "pengguna",        // ID
        "مستخدم",         // AR
        "صارف",           // UR
        "用户",            // ZH
    },
    Email: LocStr{
        "email",           // EN
        "correo",          // ES
        "email",           // PT
        "courriel",        // FR
        "электронная почта", // RU
        "E-Mail",          // DE
        "email",           // IT
        "ईमेल",            // HI
        "ইমেইল",           // BN
        "email",           // ID
        "بريد إلكتروني",   // AR
        "ای میل",          // UR
        "邮箱",            // ZH
    },
    // ... more custom words
}

// Combine system dictionary with custom words
OutLang(ES) // Spanish
err := Err(MD.User, D.Not, D.Found)
// out: "usuario no encontrado"

err := Err(D.Format,MD.Email, D.Invalid) 
// out: "formato correo inválido"
```

#### 🔧 Language Configuration

```go
// Set specific language
OutLang(ES)    // Spanish
OutLang(FR)    // French
OutLang(ZH)    // Chinese

// Auto-detect system language
OutLang()      // Detects from environment variables (backend) or browser (WASM)

// Override language inline
err := Err(DE, D.Invalid, D.Value)  // Force German
// out: "ungültig Wert"
```

Features not available in Go's standard library:

### 🌍 Multilingual Dictionary System

TinyString includes a comprehensive multilingual error system with zero external dependencies:

```go
import . "github.com/cdvelop/tinystring"

// Auto-detect system language or set explicitly
OutLang()    // Auto-detect from environment/browser
OutLang(ES)  // Set Spanish explicitly

// Basic error creation with dictionary words
err := Err(D.Invalid, D.Format)
// out: "inválido formato" (Spanish)

// Complex compositions
err := Err(D.Cannot, D.Round, D.NonNumeric, D.Value)
// out: "no puede redondear no numérico valor" (Spanish)

// Dynamic language switching
err := Err(FR, D.Empty, D.String, D.Not, D.Supported)
// out: "vide chaîne pas pris en charge" (French)

// Mixed with regular strings (backward compatible)
err := Err(D.Invalid, "user input:", "abc123")
// out: "inválido user input: abc123"

// Practical validation example
validateInput := func(input string) error {
    if input == "" {
        return Err(D.Empty, D.String, D.Not, D.Supported)
    }
    if _, err := Convert(input).ToInt(); err != nil {
        return Err(D.Invalid, D.Number, D.Format)
    }
    return nil
}
```

#### 🎯 Dictionary Features
- **9 Languages**: EN, ES, ZH, HI, AR, PT, FR, DE, RU
- **35+ Essential Words**: Alphabetically sorted for maximum reusability
- **Composable Messages**: Build complex errors from simple words
- **Zero Dependencies**: No external translation libraries
- **Auto-Detection**: Automatically detects system/browser language
- **TinyGo Compatible**: Full WebAssembly support

### 🌍 Unicode & Localization

```go
// Remove accents and diacritics
tinystring.Convert("café naïve résumé").RemoveTilde().String()  // out: "cafe naive resume"
tinystring.Convert("Ñoño niño").RemoveTilde().String()          // out: "Nono nino"
```

### ✂️ Smart Truncation

```go
// Basic truncation with ellipsis
tinystring.Convert("Hello, World!").Truncate(10).String()       // out: "Hello, ..."

// Name truncation for UI display
tinystring.Convert("Jeronimo Dominguez").TruncateName(3, 15).String()
// out: "Jer. Dominguez"

// Advanced name handling
tinystring.Convert("Juan Carlos Rodriguez").TruncateName(3, 20).String()
// out: "Jua. Car. Rodriguez"
```

### 🔧 Advanced Utilities

```go
// Key-value parsing
value, err := tinystring.ParseKeyValue("user:admin")            // out: "admin", nil
value, err := tinystring.ParseKeyValue("count=42", "=")         // out: "42", nil

// Snake case with custom separators
tinystring.Convert("hello world").ToSnakeCaseLower("-").String() // out: "hello-world"
tinystring.Convert("hello world").ToSnakeCaseUpper("_").String() // out: "HELLO_WORLD"
```

## 💡 Performance Tips

### Memory Optimization

```go
// ✅ Efficient: Modify original string directly
original := "Él Múrcielago Rápido"
tinystring.Convert(&original).RemoveTilde().ToLower().Apply()
// original is now modified in-place

// ❌ Less efficient: Creates new string
original := "Él Múrcielago Rápido"  
result := tinystring.Convert(original).RemoveTilde().ToLower().String()
```

### Chaining Operations

```go
// Combine multiple operations efficiently
result := tinystring.Convert("  HÓLA MÚNDO  ")
    .Trim()
    .RemoveTilde()
    .ToLower()
    .Replace(" ", "_")
    .String()
// out: "hola_mundo"
```

## 🔄 Output Methods: String() vs Apply()

Choose between two approaches for finalizing operations:

```go
// ✅ String() - Returns result, keeps original unchanged
originalText := "Él Múrcielago Rápido"
result := tinystring.Convert(&originalText).RemoveTilde().ToLower().String()
// result: "el murcielago rapido"
// originalText: "Él Múrcielago Rápido" (unchanged)

// ✅ Apply() - Modifies original string directly (memory efficient)
originalText := "Él Múrcielago Rápido"
tinystring.Convert(&originalText).RemoveTilde().ToLower().Apply()
// originalText: "el murcielago rapido" (modified in-place)
```


## Binary Size Comparison

[Standard Library Example](benchmark/bench-binary-size/standard-lib/main.go) | [TinyString Example](benchmark/bench-binary-size/tinystring-lib/main.go)

<!-- This table is automatically generated from build-and-measure.sh -->
*Last updated: 2025-06-19 21:31:55*

| Build Type | Parameters | Standard Library<br/>`go build` | TinyString<br/>`tinygo build` | Size Reduction | Performance |
|------------|------------|------------------|------------|----------------|-------------|
| 🖥️ **Default Native** | `-ldflags="-s -w"` | 1.3 MB | 1.1 MB | **-193.5 KB** | ➖ **14.7%** |
| 🌐 **Default WASM** | `(default -opt=z)` | 580.8 KB | 260.5 KB | **-320.3 KB** | ✅ **55.1%** |
| 🌐 **Ultra WASM** | `-no-debug -panic=trap -scheduler=none -gc=leaking -target wasm` | 141.3 KB | 35.1 KB | **-106.2 KB** | 🏆 **75.1%** |
| 🌐 **Speed WASM** | `-opt=2 -target wasm` | 827.0 KB | 334.9 KB | **-492.0 KB** | ✅ **59.5%** |
| 🌐 **Debug WASM** | `-opt=0 -target wasm` | 1.8 MB | 900.9 KB | **-931.6 KB** | ✅ **50.8%** |

### 🎯 Performance Summary

- 🏆 **Peak Reduction: 75.1%** (Best optimization)
- ✅ **Average WebAssembly Reduction: 60.2%**
- ✅ **Average Native Reduction: 14.7%**
- 📦 **Total Size Savings: 2.0 MB across all builds**

#### Performance Legend
- ❌ Poor (<5% reduction)
- ➖ Fair (5-15% reduction)
- ✅ Good (15-70% reduction)
- 🏆 Outstanding (>70% reduction)


## Memory Usage Comparison

[Standard Library Example](benchmark/bench-memory-alloc/standard) | [TinyString Example](benchmark/bench-memory-alloc/tinystring)

<!-- This table is automatically generated from memory-benchmark.sh -->
*Last updated: 2025-06-19 21:32:14*

Performance benchmarks comparing memory allocation patterns between standard Go library and TinyString:

| 🧪 **Benchmark Category** | 📚 **Library** | 💾 **Memory/Op** | 🔢 **Allocs/Op** | ⏱️ **Time/Op** | 📈 **Memory Trend** | 🎯 **Alloc Trend** | 🏆 **Performance** |
|----------------------------|----------------|-------------------|-------------------|-----------------|---------------------|---------------------|--------------------|
| 📝 **String Processing** | 📊 Standard | `1.2 KB` | `48` | `3.5μs` | - | - | - |
| | 🚀 TinyString | `2.8 KB` | `119` | `14.8μs` | ❌ **140.3% more** | ❌ **147.9% more** | ❌ **Poor** |
| 🔢 **Number Processing** | 📊 Standard | `912 B` | `42` | `2.7μs` | - | - | - |
| | 🚀 TinyString | `4.4 KB` | `88` | `6.0μs` | ❌ **389.8% more** | ❌ **109.5% more** | ❌ **Poor** |
| 🔄 **Mixed Operations** | 📊 Standard | `512 B` | `26` | `1.9μs` | - | - | - |
| | 🚀 TinyString | `1.7 KB` | `54` | `5.7μs` | ❌ **243.9% more** | ❌ **107.7% more** | ❌ **Poor** |

### 🎯 Performance Summary

- 💾 **Memory Efficiency**: ❌ **Poor** (Significant overhead) (258.0% average change)
- 🔢 **Allocation Efficiency**: ❌ **Poor** (Excessive allocations) (121.7% average change)
- 📊 **Benchmarks Analyzed**: 3 categories
- 🎯 **Optimization Focus**: Binary size reduction vs runtime efficiency

### ⚖️ Trade-offs Analysis

The benchmarks reveal important trade-offs between **binary size** and **runtime performance**:

#### 📦 **Binary Size Benefits** ✅
- 🏆 **16-84% smaller** compiled binaries
- 🌐 **Superior WebAssembly** compression ratios
- 🚀 **Faster deployment** and distribution
- 💾 **Lower storage** requirements

#### 🧠 **Runtime Memory Considerations** ⚠️
- 📈 **Higher allocation overhead** during execution
- 🗑️ **Increased GC pressure** due to allocation patterns
- ⚡ **Trade-off optimizes** for distribution size over runtime efficiency
- 🔄 **Different optimization strategy** than standard library

#### 🎯 **Optimization Recommendations**
| 🎯 **Use Case** | 💡 **Recommendation** | 🔧 **Best For** |
|-----------------|------------------------|------------------|
| 🌐 WebAssembly Apps | ✅ **TinyString** | Size-critical web deployment |
| 📱 Embedded Systems | ✅ **TinyString** | Resource-constrained devices |
| ☁️ Edge Computing | ✅ **TinyString** | Fast startup and deployment |
| 🏢 Memory-Intensive Server | ⚠️ **Standard Library** | High-throughput applications |
| 🔄 High-Frequency Processing | ⚠️ **Standard Library** | Performance-critical workloads |

#### 📊 **Performance Legend**
- 🏆 **Excellent** (Better performance)
- ✅ **Good** (Acceptable trade-off)
- ⚠️ **Caution** (Higher resource usage)
- ❌ **Poor** (Significant overhead)


## Contributing

This project is currently being **self-financed** and developed independently. The development, testing, maintenance, and improvements are funded entirely out of my personal resources and time.

If you find this project useful and would like to support its continued development, you can make a donation [here with PayPal](https://paypal.me/cdvelop?country.x=CL&locale.x=es_XC). Your support helps cover:

- 💻 Development time and effort
- 🧪 Testing and quality assurance
- 📚 Documentation improvements
- 🔧 Bug fixes and feature enhancements
- 🌐 Community support and maintenance

Any contribution, however small, is greatly appreciated and directly impacts the project's future development. 🙌

## License

MIT License
